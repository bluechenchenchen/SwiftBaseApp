# Swift 变量类型详解

## 1. 基本数据类型

### 1.1 整数类型

Swift 提供了多种整数类型，可以根据需要选择合适的类型：

```swift
// 有符号整数
let int8: Int8 = 127           // -128 到 127
let int16: Int16 = 32767       // -32768 到 32767
let int32: Int32 = 2147483647  // -2147483648 到 2147483647
let int64: Int64 = 9223372036854775807 // -9223372036854775808 到 9223372036854775807

// 无符号整数
let uint8: UInt8 = 255         // 0 到 255
let uint16: UInt16 = 65535     // 0 到 65535
let uint32: UInt32 = 4294967295 // 0 到 4294967295
let uint64: UInt64 = 18446744073709551615 // 0 到 18446744073709551615

// 平台相关整数
let int: Int = 42    // 在64位平台上等同于Int64，在32位平台上等同于Int32
let uint: UInt = 42  // 在64位平台上等同于UInt64，在32位平台上等同于UInt32
```

最佳实践：

- 除非有特殊需求，一般使用`Int`类型
- 处理文件大小时考虑使用`UInt64`
- 处理小范围数据时可以使用`Int8`或`UInt8`来节省内存

### 1.2 浮点数类型

```swift
// Float: 32位浮点数，精度约为6位小数
let float: Float = 3.14159     // ±3.4e±38 范围内的值

// Double: 64位浮点数，精度约为15位小数
let double: Double = 3.141592653589793 // ±1.7e±308 范围内的值

// 类型推断
let pi = 3.14159 // 默认推断为Double类型
```

最佳实践：

- 默认使用`Double`类型，因为它提供更高的精度
- 只有在内存特别紧张且不需要高精度的情况下才使用`Float`
- 金融计算建议使用`Decimal`类型而不是浮点数

### 1.3 布尔类型

```swift
let isEnabled: Bool = true
let isVisible = false  // 类型推断

// 条件判断
if isEnabled {
    print("已启用")
}

// 布尔运算
let andResult = true && false  // false
let orResult = true || false   // true
let notResult = !true         // false
```

最佳实践：

- 使用描述性的布尔变量名，通常以 is、has、can 等开头
- 避免使用否定形式的变量名（如 isNotEnabled）

### 1.4 字符串和字符

```swift
// 字符串
let greeting: String = "Hello, Swift!"
let multiline = """
这是一个多行
字符串的例子
支持换行
"""

// 字符
let char: Character = "A"
let emoji: Character = "🚀"

// 字符串插值
let name = "张三"
let age = 25
let introduction = "我叫\(name)，今年\(age)岁"

// 字符串操作
let str1 = "Hello"
let str2 = "World"
let combined = str1 + " " + str2
let length = combined.count
```

最佳实践：

- 使用字符串插值而不是字符串拼接
- 对于大量文本处理，考虑使用`StringBuilder`模式
- 注意字符串的内存开销，避免不必要的字符串操作

## 2. 复合类型

### 2.1 数组（Array）

```swift
// 显式类型声明
let numbers: [Int] = [1, 2, 3, 4, 5]
var strings: Array<String> = ["A", "B", "C"]

// 类型推断
let fruits = ["苹果", "香蕉", "橙子"]

// 创建空数组
var emptyArray1: [Int] = []
var emptyArray2 = [Int]()

// 数组操作
var mutableArray = [1, 2, 3]
mutableArray.append(4)        // 添加元素
mutableArray.remove(at: 0)    // 删除元素
mutableArray[1] = 5          // 修改元素
```

最佳实践：

- 优先使用类型推断，除非需要明确指定类型
- 考虑数组容量，使用`reserveCapacity()`优化性能
- 使用`isEmpty`而不是`count == 0`检查空数组

### 2.2 字典（Dictionary）

```swift
// 显式类型声明
let scores: [String: Int] = ["语文": 95, "数学": 98]
var config: Dictionary<String, Any> = ["timeout": 30, "enabled": true]

// 类型推断
let userInfo = ["name": "李四", "age": 25]

// 创建空字典
var emptyDict1: [String: Int] = [:]
var emptyDict2 = [String: Int]()

// 字典操作
var mutableDict = ["a": 1, "b": 2]
mutableDict["c"] = 3         // 添加/修改键值对
mutableDict.removeValue(forKey: "a")  // 删除键值对
```

最佳实践：

- 使用明确的键类型，避免使用 Any
- 访问值时使用可选绑定
- 考虑使用`updateValue(_:forKey:)`而不是下标，因为它返回旧值

### 2.3 集合（Set）

```swift
// 显式类型声明
let colors: Set<String> = ["红", "绿", "蓝"]
var numbers: Set<Int> = [1, 2, 3, 4, 5]

// 创建空集合
var emptySet = Set<String>()

// 集合操作
var set1: Set = [1, 2, 3]
var set2: Set = [3, 4, 5]
let union = set1.union(set2)           // 并集
let intersection = set1.intersection(set2)  // 交集
let difference = set1.symmetricDifference(set2)  // 对称差
```

最佳实践：

- 用于需要唯一性的数据集合
- 执行集合运算时优先使用 Set 而不是 Array
- 考虑使用 Set 来提高查找性能

## 3. 可选类型（Optionals）

```swift
// 可选类型声明
var optionalString: String?
var optionalNumber: Int? = nil

// 安全解包
if let string = optionalString {
    print("值为: \(string)")
}

// 强制解包（谨慎使用）
let forcedString = optionalString!

// 可选链
let optionalArray: [String]? = ["Hello"]
let count = optionalArray?.count

// 空合运算符
let defaultValue = optionalNumber ?? 0

// guard let 语法
func processOptional() {
    guard let value = optionalNumber else {
        return
    }
    print("处理值: \(value)")
}
```

最佳实践：

- 避免强制解包，除非确定值一定存在
- 优先使用`if let`和`guard let`进行安全解包
- 考虑使用空合运算符提供默认值
- 使用可选链而不是多重条件判断

## 4. 类型别名

```swift
// 为现有类型创建新名称
typealias UserID = Int
typealias Point = (x: Double, y: Double)
typealias Handler = (Data?, Error?) -> Void

// 使用类型别名
let userId: UserID = 12345
let position: Point = (x: 10.0, y: 20.0)
let handler: Handler = { data, error in
    // 处理回调
}
```

最佳实践：

- 使用类型别名提高代码可读性
- 为复杂的闭包类型创建别名
- 使用有意义的名称

## 5. 总结

### 类型选择建议

1. 整数类型选择：

   - 一般使用：`Int`
   - 明确无符号：`UInt`
   - 特定位数需求：`Int8`/`Int16`/`Int32`/`Int64`

2. 浮点数选择：

   - 一般使用：`Double`
   - 内存受限：`Float`
   - 金融计算：`Decimal`

3. 集合类型选择：
   - 有序列表：`Array`
   - 键值对：`Dictionary`
   - 唯一性集合：`Set`

### 性能考虑

1. 值类型（struct）vs 引用类型（class）：

   - 小型数据结构使用值类型
   - 需要共享状态时使用引用类型

2. 内存优化：

   - 使用适当大小的整数类型
   - 避免过度使用可选类型
   - 注意字符串的内存开销

3. 类型安全：
   - 尽量避免使用 Any 和 AnyObject
   - 使用泛型增加类型安全性
   - 正确处理可选类型

### 代码风格

1. 命名规范：

   - 使用驼峰命名法
   - 类型名称首字母大写
   - 变量和函数名称首字母小写

2. 类型注解：

   - 当类型推断不明确时使用显式类型注解
   - 公开 API 总是显式声明类型
   - 私有实现可以依赖类型推断

3. 可选类型处理：
   - 优先使用可选绑定
   - 避免强制解包
   - 合理使用隐式解包可选类型
