# Swift 面向对象编程完全指南

## 1. 什么是面向对象编程？

面向对象编程（Object-Oriented Programming，简称 OOP）是一种编程范式，它将程序看作是一组对象的集合。每个对象都包含数据和操作这些数据的方法。

### 1.1 面向对象的基本概念

1. **类（Class）**：对象的模板，定义对象的属性和行为
2. **对象（Object）**：类的实例，具体的实体
3. **封装（Encapsulation）**：将数据和方法捆绑在一起，隐藏内部细节
4. **继承（Inheritance）**：子类继承父类的特性
5. **多态（Polymorphism）**：同一个方法在不同类中有不同的实现

### 1.2 为什么要使用面向对象？

```swift
// 不使用面向对象
var studentName = "张三"
var studentAge = 18
var studentScore = 95

func printStudentInfo() {
    print("\(studentName), \(studentAge)岁, 成绩：\(studentScore)")
}

// 使用面向对象
class Student {
    var name: String
    var age: Int
    var score: Int

    init(name: String, age: Int, score: Int) {
        self.name = name
        self.age = age
        self.score = score
    }

    func printInfo() {
        print("\(name), \(age)岁, 成绩：\(score)")
    }
}

let student = Student(name: "张三", age: 18, score: 95)
student.printInfo()
```

## 2. 类和对象

### 2.1 类的定义和基本结构

```swift
class Person {
    // 属性（Properties）
    var name: String        // 存储属性
    var age: Int
    let id: String         // 常量属性

    // 计算属性
    var description: String {
        return "\(name), \(age)岁"
    }

    // 构造器（Initializer）
    init(name: String, age: Int) {
        self.name = name
        self.age = age
        self.id = UUID().uuidString
    }

    // 方法（Methods）
    func introduce() {
        print("我是\(name)，今年\(age)岁")
    }
}

// 创建对象
let person = Person(name: "李四", age: 25)
person.introduce()
```

### 2.2 属性观察器

```swift
class BankAccount {
    var accountNumber: String
    var balance: Double {
        // 属性将要被设置时调用
        willSet(newBalance) {
            print("余额将要从 \(balance) 变为 \(newBalance)")
        }
        // 属性已经被设置后调用
        didSet {
            print("余额已经从 \(oldValue) 变为 \(balance)")
            if balance < 0 {
                print("警告：账户出现透支！")
            }
        }
    }

    init(accountNumber: String, initialBalance: Double) {
        self.accountNumber = accountNumber
        self.balance = initialBalance
    }
}

let account = BankAccount(accountNumber: "1234567890", initialBalance: 1000)
account.balance -= 500  // 取款500
account.balance += 1000 // 存款1000
```

### 2.3 类型属性和方法

```swift
class Temperature {
    // 类型属性（使用 static 关键字）
    static let freezingPoint = 0.0
    static let boilingPoint = 100.0

    // 类型方法
    static func isFreezing(_ temperature: Double) -> Bool {
        return temperature <= freezingPoint
    }

    // 实例属性
    var current: Double

    init(current: Double) {
        self.current = current
    }
}

// 使用类型属性和方法
print("水的冰点是：\(Temperature.freezingPoint)°C")
print("水的沸点是：\(Temperature.boilingPoint)°C")

let temp = Temperature(current: -5)
if Temperature.isFreezing(temp.current) {
    print("温度低于冰点")
}
```

## 3. 封装

### 3.1 访问控制

Swift 提供了五个访问级别：

- `private`: 只能在当前定义中访问
- `fileprivate`: 只能在当前源文件中访问
- `internal`: 默认级别，可以在同一模块中访问
- `public`: 可以在任何模块中访问
- `open`: 可以在任何模块中访问和继承

```swift
class BankAccount {
    // 私有属性，只能在类内部访问
    private var pin: String

    // 内部属性，同一模块可以访问
    internal var balance: Double

    // 公开属性，任何地方都可以访问
    public var accountNumber: String

    public init(accountNumber: String, pin: String) {
        self.accountNumber = accountNumber
        self.pin = pin
        self.balance = 0.0
    }

    // 私有方法
    private func validatePin(_ inputPin: String) -> Bool {
        return pin == inputPin
    }

    // 公开方法
    public func withdraw(amount: Double, pin: String) -> Bool {
        guard validatePin(pin) else {
            print("PIN码错误")
            return false
        }

        guard balance >= amount else {
            print("余额不足")
            return false
        }

        balance -= amount
        return true
    }
}

let account = BankAccount(accountNumber: "1234567890", pin: "1234")
// account.pin // 错误：无法访问私有属性
account.withdraw(amount: 100, pin: "1234") // 可以访问公开方法
```

## 4. 继承

### 4.1 基本继承

```swift
// 基类（父类）
class Vehicle {
    var brand: String
    var model: String
    var year: Int

    init(brand: String, model: String, year: Int) {
        self.brand = brand
        self.model = model
        self.year = year
    }

    func start() {
        print("启动车辆")
    }

    func stop() {
        print("停止车辆")
    }
}

// 子类
class Car: Vehicle {
    var numberOfDoors: Int

    init(brand: String, model: String, year: Int, numberOfDoors: Int) {
        // 先初始化子类特有的属性
        self.numberOfDoors = numberOfDoors
        // 调用父类的初始化器
        super.init(brand: brand, model: model, year: year)
    }

    // 重写父类方法
    override func start() {
        super.start() // 调用父类的方法
        print("汽车特有的启动程序")
    }
}

let myCar = Car(brand: "Toyota", model: "Camry", year: 2023, numberOfDoors: 4)
myCar.start()
```

### 4.2 防止继承

```swift
// 使用 final 关键字防止类被继承
final class CreditCard {
    let number: String
    let expiryDate: String

    init(number: String, expiryDate: String) {
        self.number = number
        self.expiryDate = expiryDate
    }
}

// 错误：不能继承 final 类
// class DebitCard: CreditCard { }
```

## 5. 多态

### 5.1 方法多态

```swift
class Animal {
    func makeSound() {
        print("动物发出声音")
    }
}

class Dog: Animal {
    override func makeSound() {
        print("汪汪!")
    }
}

class Cat: Animal {
    override func makeSound() {
        print("喵喵!")
    }
}

// 多态示例
let animals: [Animal] = [Dog(), Cat()]
for animal in animals {
    animal.makeSound() // 会根据实际类型调用相应的方法
}
```

### 5.2 类型检查和转换

```swift
class MediaItem {
    var name: String

    init(name: String) {
        self.name = name
    }
}

class Movie: MediaItem {
    var director: String

    init(name: String, director: String) {
        self.director = director
        super.init(name: name)
    }
}

class Song: MediaItem {
    var artist: String

    init(name: String, artist: String) {
        self.artist = artist
        super.init(name: name)
    }
}

let library = [
    Movie(name: "星际穿越", director: "克里斯托弗·诺兰"),
    Song(name: "晴天", artist: "周杰伦"),
    Movie(name: "盗梦空间", director: "克里斯托弗·诺兰")
]

// 类型检查
for item in library {
    if item is Movie {
        print("\(item.name) 是一部电影")
    } else if item is Song {
        print("\(item.name) 是一首歌")
    }
}

// 类型转换
for item in library {
    if let movie = item as? Movie {
        print("电影：\(movie.name)，导演：\(movie.director)")
    } else if let song = item as? Song {
        print("歌曲：\(song.name)，艺术家：\(song.artist)")
    }
}
```

## 6. 协议（Protocols）

协议定义了一个蓝图，规定了用来实现某一特定任务或功能的方法、属性和其他要求。

### 6.1 基本协议

```swift
// 定义协议
protocol Playable {
    // 属性要求
    var isPlaying: Bool { get set }

    // 方法要求
    func play()
    func pause()
    func stop()
}

// 实现协议
class AudioPlayer: Playable {
    var isPlaying: Bool = false

    func play() {
        isPlaying = true
        print("开始播放音频")
    }

    func pause() {
        isPlaying = false
        print("暂停播放音频")
    }

    func stop() {
        isPlaying = false
        print("停止播放音频")
    }
}

class VideoPlayer: Playable {
    var isPlaying: Bool = false

    func play() {
        isPlaying = true
        print("开始播放视频")
    }

    func pause() {
        isPlaying = false
        print("暂停播放视频")
    }

    func stop() {
        isPlaying = false
        print("停止播放视频")
    }
}

// 使用协议类型
func playMedia(_ player: Playable) {
    player.play()
}

let audioPlayer = AudioPlayer()
let videoPlayer = VideoPlayer()

playMedia(audioPlayer)
playMedia(videoPlayer)
```

### 6.2 协议扩展

```swift
protocol Drawable {
    func draw()
}

// 为协议提供默认实现
extension Drawable {
    func draw() {
        print("绘制默认图形")
    }

    // 添加新的方法
    func prepare() {
        print("准备绘制")
    }
}

class Circle: Drawable {
    // 可以使用默认实现，也可以提供自己的实现
    func draw() {
        print("绘制圆形")
    }
}

class Square: Drawable {
    // 使用默认实现
}

let circle = Circle()
let square = Square()

circle.draw()    // 输出：绘制圆形
square.draw()    // 输出：绘制默认图形
circle.prepare() // 输出：准备绘制
```

## 7. 实际应用示例

### 7.1 购物车系统

```swift
// 定义商品协议
protocol Item {
    var name: String { get }
    var price: Double { get }
}

// 定义折扣协议
protocol Discountable {
    func applyDiscount(_ percent: Double) -> Double
}

// 商品类
class Product: Item {
    let name: String
    let price: Double

    init(name: String, price: Double) {
        self.name = name
        self.price = price
    }
}

// 带折扣的商品类
class DiscountedProduct: Product, Discountable {
    func applyDiscount(_ percent: Double) -> Double {
        return price * (1 - percent/100)
    }
}

// 购物车类
class ShoppingCart {
    private var items: [Item] = []

    func addItem(_ item: Item) {
        items.append(item)
    }

    func removeItem(at index: Int) {
        guard index < items.count else { return }
        items.remove(at: index)
    }

    func calculateTotal() -> Double {
        return items.reduce(0) { total, item in
            if let discountedItem = item as? Discountable {
                return total + discountedItem.applyDiscount(10) // 10%折扣
            }
            return total + item.price
        }
    }

    func printReceipt() {
        print("=== 购物清单 ===")
        items.forEach { item in
            if let discountedItem = item as? DiscountedProduct {
                let discountedPrice = discountedItem.applyDiscount(10)
                print("\(item.name): ¥\(item.price) (折扣价: ¥\(discountedPrice))")
            } else {
                print("\(item.name): ¥\(item.price)")
            }
        }
        print("总计: ¥\(calculateTotal())")
        print("==============")
    }
}

// 使用示例
let normalProduct = Product(name: "普通商品", price: 100)
let discountedProduct = DiscountedProduct(name: "促销商品", price: 200)

let cart = ShoppingCart()
cart.addItem(normalProduct)
cart.addItem(discountedProduct)
cart.printReceipt()
```

## 8. 最佳实践

### 8.1 设计原则

1. **单一职责原则**

   - 一个类应该只有一个改变的理由
   - 每个类应该只负责一个功能

2. **开放封闭原则**

   - 对扩展开放，对修改关闭
   - 使用继承和协议来扩展功能

3. **依赖倒置原则**
   - 依赖抽象而不是具体实现
   - 使用协议定义接口

### 8.2 代码风格建议

1. **命名规范**

   - 类名使用大驼峰命名法（如：`BankAccount`）
   - 方法和属性使用小驼峰命名法（如：`accountNumber`）
   - 名称应该清晰表达意图

2. **访问控制**

   - 适当使用访问修饰符
   - 不要过度暴露内部实现

3. **注释和文档**
   - 为复杂的方法添加文档注释
   - 解释重要的业务逻辑

## 9. 常见问题和解决方案

### 9.1 内存管理

```swift
// 循环引用问题
class Person {
    let name: String
    var apartment: Apartment?

    init(name: String) {
        self.name = name
    }

    deinit {
        print("\(name) 被释放")
    }
}

class Apartment {
    let number: String
    weak var tenant: Person? // 使用 weak 避免循环引用

    init(number: String) {
        self.number = number
    }

    deinit {
        print("公寓 \(number) 被释放")
    }
}

// 测试
var person: Person? = Person(name: "张三")
var apartment: Apartment? = Apartment(number: "101")

person?.apartment = apartment
apartment?.tenant = person

// 释放对象
person = nil
apartment = nil
```

### 9.2 错误处理

```swift
// 定义错误类型
enum BankError: Error {
    case insufficientFunds(needed: Double, available: Double)
    case invalidAmount
    case accountLocked
}

class BankAccount {
    var balance: Double
    var isLocked: Bool

    init(balance: Double) {
        self.balance = balance
        self.isLocked = false
    }

    func withdraw(amount: Double) throws -> Double {
        // 验证账户状态
        guard !isLocked else {
            throw BankError.accountLocked
        }

        // 验证取款金额
        guard amount > 0 else {
            throw BankError.invalidAmount
        }

        // 检查余额
        guard balance >= amount else {
            throw BankError.insufficientFunds(needed: amount, available: balance)
        }

        balance -= amount
        return balance
    }
}

// 使用示例
let account = BankAccount(balance: 1000)

do {
    let newBalance = try account.withdraw(amount: 1500)
    print("取款成功，当前余额: \(newBalance)")
} catch BankError.insufficientFunds(let needed, let available) {
    print("余额不足：需要 \(needed)，但只有 \(available)")
} catch BankError.invalidAmount {
    print("无效的取款金额")
} catch BankError.accountLocked {
    print("账户已锁定")
} catch {
    print("发生未知错误：\(error)")
}
```

## 10. 参考资料

1. [Swift 官方文档](https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html)
2. [Swift 编程语言中文版](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/07_classes_and_structures)
3. [Apple Developer Documentation](https://developer.apple.com/documentation/swift)
