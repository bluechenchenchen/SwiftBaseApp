# Swift 条件语句详解

## 1. if 条件语句

### 1.1 基本语法

```swift
// 基本if语句
let score = 85
if score >= 60 {
    print("及格")
}

// if-else语句
let temperature = 25
if temperature > 30 {
    print("天气炎热")
} else {
    print("天气适宜")
}

// if-else if-else链
let age = 25
if age < 18 {
    print("未成年人")
} else if age < 60 {
    print("成年人")
} else {
    print("老年人")
}
```

### 1.2 条件组合

```swift
// 使用逻辑运算符
let age = 25
let hasIDCard = true

// 使用 AND 运算符
if age >= 18 && hasIDCard {
    print("可以办理银行卡")
}

// 使用 OR 运算符
let isWeekend = true
let isHoliday = false
if isWeekend || isHoliday {
    print("可以休息")
}

// 使用 NOT 运算符
let isWorking = true
if !isWorking {
    print("现在是休息时间")
}

// 复杂条件组合示例
let temperature = 25
let isRaining = false
let hasUmbrella = true
if (temperature > 20 && !isRaining) || (isRaining && hasUmbrella) {
    print("适合外出")
}
```

### 1.3 最佳实践

- 条件表达式要清晰，避免过度复杂的组合
- 优先使用 guard 提前返回，提高代码可读性
- 条件语句中的布尔值不需要与 true/false 比较

## 2. guard 语句

### 2.0 什么是 guard 语句？

guard 是 Swift 中的一个特殊的条件语句，它主要用于提前退出函数或方法。你可以把它理解为一个"门卫"，它会检查某个条件是否满足：

- 如果条件满足，代码继续执行
- 如果条件不满足，必须立即退出当前作用域

#### guard 的主要特点：

1. **提前退出**

   - guard 强制要求在条件不满足时提前退出
   - 这样可以避免深层嵌套的 if-else 结构
   - 使代码更清晰、更易读

2. **条件必须有 else 子句**

   - else 子句必须退出当前作用域（使用 return, break, continue, throw 等）
   - 这保证了代码的安全性

3. **变量解包后仍然可用**
   - 通过 guard 解包的可选值，在后续代码中仍然可以使用
   - 这是与 if let 的一个重要区别

#### 与 if 语句的对比：

```swift
// 使用 if 语句
func processUser1(name: String?) {
    if let name = name {
        // name 只在这个作用域内可用
        print("欢迎, \(name)")
    } else {
        print("无效的用户名")
        return
    }
    // 这里不能使用 name
}

// 使用 guard 语句
func processUser2(name: String?) {
    guard let name = name else {
        print("无效的用户名")
        return
    }
    // name 在这里可以使用
    print("欢迎, \(name)")
    // name 在函数剩余部分都可以使用
}
```

#### 为什么要使用 guard？

1. **提高代码可读性**

   - 把错误处理代码放在前面
   - 主要逻辑代码不会被错误处理代码干扰
   - 减少嵌套层级

2. **保证安全性**

   - 强制处理所有错误情况
   - 确保代码的健壮性

3. **减少可选值处理的复杂度**

   - 解包后的值在整个函数作用域内都可用
   - 避免重复解包

4. **适合处理前置条件**
   - 参数验证
   - 状态检查
   - 权限验证

### 2.1 基本语法

```swift
// 基本的 guard 用法
func processAge(_ age: Int?) {
    guard let age = age else {
        print("年龄不能为空")
        return
    }
    // age 在这里是非空的 Int 类型
    print("年龄是 \(age) 岁")
}

// 多条件 guard 示例
func validateUser(name: String?, age: Int?, email: String?) {
    guard let name = name,
          !name.isEmpty,
          let age = age,
          age >= 0,
          let email = email,
          email.contains("@") else {
        print("用户信息无效")
        return
    }

    print("用户信息有效：\(name), \(age)岁, \(email)")
}

// 使用示例
processAge(20)  // 输出: 年龄是 20 岁
processAge(nil) // 输出: 年龄不能为空

validateUser(name: "张三", age: 25, email: "zhangsan@example.com")
validateUser(name: "", age: -1, email: "invalid_email")
```

### 2.2 常见用法

```swift
// 网络请求结果处理示例
enum NetworkError: Error {
    case invalidURL
    case noData
    case invalidResponse
}

struct User {
    let id: Int
    let name: String
}

func fetchUser(id: Int, completion: (Result<User, NetworkError>) -> Void) {
    // 模拟网络请求
    let userData: [String: Any]? = ["id": id, "name": "张三"]

    // 使用 guard 进行安全解包和验证
    guard let data = userData else {
        completion(.failure(.noData))
        return
    }

    guard let userId = data["id"] as? Int,
          let userName = data["name"] as? String else {
        completion(.failure(.invalidResponse))
        return
    }

    let user = User(id: userId, name: userName)
    completion(.success(user))
}

// 使用示例
fetchUser(id: 1) { result in
    switch result {
    case .success(let user):
        print("获取用户成功：\(user.name)")
    case .failure(let error):
        print("获取用户失败：\(error)")
    }
}
```

### 2.3 实际场景示例

```swift
// 模拟用户注册流程
struct User {
    let username: String
    let email: String
    let age: Int
    let password: String
}

enum ValidationError: Error {
    case invalidUsername
    case invalidEmail
    case invalidAge
    case invalidPassword
}

class UserRegistration {
    // 不使用 guard 的版本 - 代码嵌套层级深，难以阅读
    func registerUser1(username: String?, email: String?, age: Int?, password: String?) -> Result<User, ValidationError> {
        if let username = username, !username.isEmpty {
            if let email = email, email.contains("@") {
                if let age = age, age >= 18 {
                    if let password = password, password.count >= 6 {
                        let user = User(username: username, email: email, age: age, password: password)
                        return .success(user)
                    } else {
                        return .failure(.invalidPassword)
                    }
                } else {
                    return .failure(.invalidAge)
                }
            } else {
                return .failure(.invalidEmail)
            }
        } else {
            return .failure(.invalidUsername)
        }
    }

    // 使用 guard 的版本 - 代码更清晰，易于维护
    func registerUser2(username: String?, email: String?, age: Int?, password: String?) -> Result<User, ValidationError> {
        // 检查用户名
        guard let username = username, !username.isEmpty else {
            return .failure(.invalidUsername)
        }

        // 检查邮箱
        guard let email = email, email.contains("@") else {
            return .failure(.invalidEmail)
        }

        // 检查年龄
        guard let age = age, age >= 18 else {
            return .failure(.invalidAge)
        }

        // 检查密码
        guard let password = password, password.count >= 6 else {
            return .failure(.invalidPassword)
        }

        // 所有验证通过，创建用户
        let user = User(username: username, email: email, age: age, password: password)
        return .success(user)
    }
}

// 使用示例
let registration = UserRegistration()

// 测试有效数据
let result1 = registration.registerUser2(
    username: "zhangsan",
    email: "zhangsan@example.com",
    age: 20,
    password: "123456"
)

// 测试无效数据
let result2 = registration.registerUser2(
    username: "",
    email: "invalid_email",
    age: 16,
    password: "123"
)

// 处理结果
switch result1 {
case .success(let user):
    print("用户注册成功：\(user.username)")
case .failure(let error):
    print("注册失败：\(error)")
}
```

### 2.4 最佳实践

1. **何时使用 guard**

   - 在函数开始处验证输入参数
   - 在需要提前退出的场景
   - 处理多个可选值时
   - 检查必要的前置条件

2. **代码风格建议**

   - guard 语句应该放在函数的开始部分
   - 每个 guard 语句处理一个具体的检查
   - else 分支应该简短且只包含退出代码
   - 使用有意义的错误信息或返回值

3. **避免过度使用**
   - 不要为了使用 guard 而使用 guard
   - 简单的可选值绑定可以使用 if let
   - 当需要在 else 分支中执行复杂逻辑时，考虑使用 if 语句

## 3. switch 语句

### 3.1 基本语法

```swift
// 基本的枚举匹配
enum PaymentMethod {
    case cash
    case creditCard
    case digitalWallet
}

func processPayment(_ method: PaymentMethod, amount: Double) {
    switch method {
    case .cash:
        print("现金支付 ¥\(amount)")
    case .creditCard:
        print("信用卡支付 ¥\(amount)，额外收取3%手续费")
    case .digitalWallet:
        print("电子钱包支付 ¥\(amount)，优惠5%")
    }
}

// 使用示例
let payment1 = PaymentMethod.cash
let payment2 = PaymentMethod.creditCard
let amount = 100.0

processPayment(payment1, amount: amount)  // 输出: 现金支付 ¥100.0
processPayment(payment2, amount: amount)  // 输出: 信用卡支付 ¥100.0，额外收取3%手续费
```

### 3.2 高级特性

```swift
// 1. 区间匹配示例：学生成绩评级
func gradeStudent(score: Int) {
    switch score {
    case 90...100:
        print("优秀")
    case 80...89:
        print("良好")
    case 60...79:
        print("及格")
    case 0...59:
        print("不及格")
    default:
        print("无效分数")
    }
}

// 2. 多值匹配示例：星期几的类型判断
func checkDayType(_ day: Int) {
    switch day {
    case 1, 2, 3, 4, 5:
        print("工作日")
    case 6, 7:
        print("周末")
    default:
        print("无效日期")
    }
}

// 3. 值绑定示例：坐标系中的点分析
struct Point {
    let x: Int
    let y: Int
}

func analyzePoint(_ point: Point) {
    switch (point.x, point.y) {
    case (let x, 0):
        print("X轴上的点：(\(x), 0)")
    case (0, let y):
        print("Y轴上的点：(0, \(y))")
    case let (x, y):
        print("普通点：(\(x), \(y))")
    }
}

// 4. where子句示例：复数点的象限判断
func checkQuadrant(_ point: Point) {
    switch (point.x, point.y) {
    case let (x, y) where x > 0 && y > 0:
        print("第一象限")
    case let (x, y) where x < 0 && y > 0:
        print("第二象限")
    case let (x, y) where x < 0 && y < 0:
        print("第三象限")
    case let (x, y) where x > 0 && y < 0:
        print("第四象限")
    case (0, 0):
        print("原点")
    default:
        print("在坐标轴上")
    }
}

// 使用示例
gradeStudent(score: 85)  // 输出: 良好
checkDayType(6)         // 输出: 周末

let point1 = Point(x: 5, y: 0)
analyzePoint(point1)    // 输出: X轴上的点：(5, 0)

let point2 = Point(x: 3, y: 4)
checkQuadrant(point2)   // 输出: 第一象限
```

### 3.3 特点和优势

- 不需要 break 语句（默认不贯穿）
- 必须处理所有可能的情况
- 支持多种模式匹配
- 支持值绑定和 where 子句
- 比 if-else 链更清晰和高效

## 4. 模式匹配条件

### 4.1 if case 语法

```swift
// 定义一个表示任务状态的枚举
enum TaskStatus {
    case notStarted
    case inProgress(completionPercentage: Int)
    case completed(date: Date)
    case failed(reason: String)
}

// 创建一些示例任务
let task1 = TaskStatus.inProgress(completionPercentage: 75)
let task2 = TaskStatus.completed(date: Date())
let task3 = TaskStatus.failed(reason: "网络连接失败")

// 使用 if case 检查特定状态
func checkTaskProgress(_ task: TaskStatus) {
    // 检查进行中的任务
    if case .inProgress(let percentage) = task {
        print("任务进度：\(percentage)%")
    }

    // 使用 where 子句检查特定条件
    if case .inProgress(let percentage) = task where percentage > 50 {
        print("任务已经完成一半以上")
    }

    // 检查失败的任务
    if case .failed(let reason) = task {
        print("任务失败，原因：\(reason)")
    }
}

// 使用示例
checkTaskProgress(task1)  // 输出: 任务进度：75% 和 任务已经完成一半以上
checkTaskProgress(task3)  // 输出: 任务失败，原因：网络连接失败
```

### 4.2 for case 语法

```swift
// 定义一个表示商品的枚举
enum Product {
    case book(title: String, price: Double)
    case electronics(name: String, price: Double, warranty: Int)
    case clothing(type: String, size: String, price: Double)
}

// 创建一个商品数组
let products: [Product] = [
    .book(title: "Swift编程", price: 88.0),
    .electronics(name: "耳机", price: 999.0, warranty: 12),
    .clothing(type: "T恤", size: "L", price: 199.0),
    .book(title: "SwiftUI教程", price: 78.0),
    .electronics(name: "充电器", price: 129.0, warranty: 6)
]

// 使用 for case 筛选特定类型的商品
func printBookCatalog(_ products: [Product]) {
    print("书籍目录：")
    for case let .book(title, price) in products {
        print("《\(title)》 - ¥\(price)")
    }
}

func printElectronicsWithWarranty(_ products: [Product]) {
    print("\n电子产品保修信息：")
    for case let .electronics(name, price, warranty) in products where warranty > 6 {
        print("\(name) - ¥\(price)，保修期：\(warranty)个月")
    }
}

// 使用示例
printBookCatalog(products)
// 输出:
// 书籍目录：
// 《Swift编程》 - ¥88.0
// 《SwiftUI教程》 - ¥78.0

printElectronicsWithWarranty(products)
// 输出:
// 电子产品保修信息：
// 耳机 - ¥999.0，保修期：12个月
```

### 4.3 复合条件匹配

```swift
// 定义一个表示用户的结构体
struct User {
    let age: Int
    let gender: String
    let membership: String
    let points: Int
}

// 创建一些示例用户
let users = [
    User(age: 16, gender: "male", membership: "silver", points: 800),
    User(age: 25, gender: "female", membership: "gold", points: 1500),
    User(age: 17, gender: "female", membership: "bronze", points: 300),
    User(age: 35, gender: "male", membership: "platinum", points: 3000)
]

// 使用复合条件进行用户分类
func categorizeUser(_ user: User) {
    // switch 语句中的复合匹配
    switch (user.age, user.gender, user.membership) {
    case (0...18, "male", _):
        print("未成年男性会员")
    case (0...18, "female", _):
        print("未成年女性会员")
    case (_, _, "platinum") where user.points >= 3000:
        print("高级白金会员")
    case (_, _, "gold") where user.points >= 1000:
        print("高级黄金会员")
    default:
        print("普通会员")
    }

    // if case 中的复合条件
    if case (18...25, "female", "gold") = (user.age, user.gender, user.membership) {
        print("年轻女性黄金会员专享优惠")
    }
}

// 使用示例
for user in users {
    print("\n分析用户：\(user.age)岁，\(user.gender)，\(user.membership)会员，\(user.points)积分")
    categorizeUser(user)
}

// 输出示例：
// 分析用户：16岁，male，silver会员，800积分
// 未成年男性会员

// 分析用户：25岁，female，gold会员，1500积分
// 高级黄金会员

// 分析用户：17岁，female，bronze会员，300积分
// 未成年女性会员

// 分析用户：35岁，male，platinum会员，3000积分
// 高级白金会员
```

## 5. 循环控制语句

### 5.1 repeat-while 循环

```swift
// 模拟网络请求重试机制
class NetworkManager {
    enum NetworkError: Error {
        case connectionFailed
        case timeout
        case serverError
    }

    func simulateNetworkCall() throws {
        // 模拟随机网络错误
        let random = Int.random(in: 1...3)
        if random == 1 {
            throw NetworkError.connectionFailed
        }
    }

    func fetchDataWithRetry(maxAttempts: Int = 3) {
        var attempts = 0
        var succeeded = false

        repeat {
            attempts += 1
            print("\n尝试第 \(attempts) 次请求...")

            do {
                try simulateNetworkCall()
                print("请求成功！")
                succeeded = true
            } catch {
                print("请求失败：\(error)")
                if attempts == maxAttempts {
                    print("达到最大重试次数，放弃请求")
                } else {
                    print("等待后重试...")
                    Thread.sleep(forTimeInterval: 1) // 模拟等待时间
                }
            }
        } while !succeeded && attempts < maxAttempts
    }
}

// 使用示例
let network = NetworkManager()
network.fetchDataWithRetry()

// 可能的输出示例：
// 尝试第 1 次请求...
// 请求失败：connectionFailed
// 等待后重试...
//
// 尝试第 2 次请求...
// 请求失败：connectionFailed
// 等待后重试...
//
// 尝试第 3 次请求...
// 请求成功！
```

### 5.2 switch 的 fallthrough

```swift
// 模拟游戏角色升级系统
struct GameCharacter {
    var name: String
    var level: Int
    var experience: Int = 0
    var skills: [String] = []

    mutating func levelUp() {
        level += 1
        print("\n\(name) 升级到 \(level) 级！")

        // 使用 fallthrough 实现技能连续解锁
        switch level {
        case 5:
            print("解锁基础技能：冲刺")
            skills.append("冲刺")
            fallthrough
        case 4:
            print("解锁基础技能：格挡")
            skills.append("格挡")
            fallthrough
        case 3:
            print("解锁基础技能：跳跃")
            skills.append("跳跃")
            fallthrough
        case 2:
            print("解锁基础技能：跑步")
            skills.append("跑步")
            fallthrough
        case 1:
            print("解锁基础技能：行走")
            skills.append("行走")
        default:
            if level > 5 {
                print("解锁高级技能：连击")
                skills.append("连击")
            }
        }

        print("\n当前已解锁技能：\(skills.joined(separator: ", "))")
    }
}

// 使用示例
var hero = GameCharacter(name: "勇者", level: 1)
hero.levelUp()  // 升到2级
hero.levelUp()  // 升到3级
hero.levelUp()  // 升到4级
hero.levelUp()  // 升到5级

// 输出示例：
// 勇者 升级到 2 级！
// 解锁基础技能：跑步
// 解锁基础技能：行走
//
// 当前已解锁技能：跑步, 行走
//
// 勇者 升级到 3 级！
// 解锁基础技能：跳跃
// 解锁基础技能：跑步
// 解锁基础技能：行走
//
// 当前已解锁技能：跳跃, 跑步, 行走
//
// ...以此类推
```

## 6. 条件运算符

### 6.1 三元运算符

```swift
// 使用三元运算符的实际示例
struct Product {
    let name: String
    let price: Double
    let isOnSale: Bool

    // 使用三元运算符计算折扣价格
    var finalPrice: Double {
        return isOnSale ? price * 0.8 : price
    }

    // 使用三元运算符生成显示文本
    var priceDisplay: String {
        return isOnSale ? "促销价: ¥\(finalPrice)" : "原价: ¥\(price)"
    }

    // 使用三元运算符设置标签样式
    var priceColor: String {
        return isOnSale ? "红色" : "黑色"
    }
}

// 使用示例
let products = [
    Product(name: "iPhone", price: 6999, isOnSale: true),
    Product(name: "iPad", price: 3999, isOnSale: false),
    Product(name: "MacBook", price: 9999, isOnSale: true)
]

// 展示商品信息
for product in products {
    print("\n商品：\(product.name)")
    print(product.priceDisplay)
    print("价格标签颜色：\(product.priceColor)")
}

// 输出：
// 商品：iPhone
// 促销价: ¥5599.2
// 价格标签颜色：红色
//
// 商品：iPad
// 原价: ¥3999.0
// 价格标签颜色：黑色
//
// 商品：MacBook
// 促销价: ¥7999.2
// 价格标签颜色：红色
```

### 6.2 空合运算符

```swift
// 用户配置管理示例
struct UserPreferences {
    // 从存储中读取的可选值
    var savedUsername: String?
    var savedTheme: String?
    var savedFontSize: Int?
    var savedLanguage: String?

    // 使用空合运算符提供默认值
    var username: String {
        return savedUsername ?? "游客"
    }

    // 链式使用空合运算符
    var theme: String {
        return savedTheme ?? UserDefaults.standard.string(forKey: "theme") ?? "light"
    }

    // 结合类型转换和空合运算符
    var fontSize: Int {
        return savedFontSize ?? 14
    }

    // 多重保障的默认值设置
    var language: String {
        return savedLanguage ??
               Locale.current.languageCode ??
               "zh-CN"
    }

    // 打印当前配置
    func printConfig() {
        print("""
            当前用户配置：
            用户名：\(username)
            主题：\(theme)
            字体大小：\(fontSize)
            语言：\(language)
            """)
    }
}

// 使用示例
// 1. 全部使用默认值
var prefs1 = UserPreferences()
prefs1.printConfig()

// 2. 部分设置值
var prefs2 = UserPreferences(
    savedUsername: "张三",
    savedTheme: nil,
    savedFontSize: 16,
    savedLanguage: nil
)
prefs2.printConfig()

// 输出示例：
// 当前用户配置：
// 用户名：游客
// 主题：light
// 字体大小：14
// 语言：zh-CN
//
// 当前用户配置：
// 用户名：张三
// 主题：light
// 字体大小：16
// 语言：zh-CN
```

## 5. 最佳实践总结

### 5.1 选择合适的条件语句

- 简单条件判断：使用 if 语句
- 提前退出场景：使用 guard 语句
- 多分支条件：使用 switch 语句
- 简单的条件赋值：使用三元运算符
- 可选值处理：使用空合运算符

### 5.2 代码风格建议

- 保持条件表达式的简洁性
- 避免过度嵌套条件语句
- 优先使用 guard 提前返回
- switch 语句要处理所有可能情况
- 合理使用空合运算符，但不要过度使用

### 5.3 安全性考虑

- 正确处理可选值
- 避免强制解包
- 确保 switch 语句涵盖所有情况
- 条件组合时注意逻辑运算符优先级

## 6. 示例场景

### 6.1 用户输入验证

```swift
func validateUserInput(name: String?, age: Int?) {
    // 使用guard进行前置条件检查
    guard let name = name, !name.isEmpty else {
        print("名字不能为空")
        return
    }

    guard let age = age, age >= 0 else {
        print("年龄必须是非负数")
        return
    }

    // 使用switch进行年龄分类
    switch age {
    case 0...17:
        print("\(name) 是未成年人")
    case 18...65:
        print("\(name) 是成年人")
    default:
        print("\(name) 是老年人")
    }
}
```

### 6.2 状态处理

```swift
enum ConnectionState {
    case disconnected
    case connecting
    case connected
    case failed(Error)
}

func handleConnectionState(_ state: ConnectionState) {
    switch state {
    case .disconnected:
        print("未连接")
    case .connecting:
        print("连接中...")
    case .connected:
        print("已连接")
    case .failed(let error):
        print("连接失败: \(error.localizedDescription)")
    }
}
```

## 7. 参考资料

- [Swift 官方文档](https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html)
- [Swift 编程语言中文版](https://swiftgg.gitbook.io/swift/swift-jiao-cheng/05_control_flow)
