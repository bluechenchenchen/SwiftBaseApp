# Swift 函数式编程指南

## 1. 函数式编程基础

### 1.1 什么是函数式编程？

函数式编程是一种编程范式，它强调：

- 使用不可变数据
- 将函数作为一等公民
- 使用纯函数（相同输入总是产生相同输出）
- 避免副作用
- 声明式而非命令式编程

### 1.2 Swift 中的函数式特性

```swift
// 函数作为变量
let greet: (String) -> String = { name in
    return "Hello, \(name)!"
}

// 函数作为参数
func perform(_ operation: (Int, Int) -> Int, on a: Int, and b: Int) -> Int {
    return operation(a, b)
}

// 函数作为返回值
func makeMultiplier(factor: Int) -> (Int) -> Int {
    return { number in number * factor }
}
```

## 2. 高阶函数

### 2.1 map

将数组中的每个元素转换为新的元素：

```swift
// 基本用法
let numbers = [1, 2, 3, 4, 5]
let doubled = numbers.map { $0 * 2 } // [2, 4, 6, 8, 10]

// 转换类型
let stringNumbers = numbers.map { String($0) } // ["1", "2", "3", "4", "5"]

// 处理可选值
let optionals: [Int?] = [1, nil, 3, nil, 5]
let mapped = optionals.map { $0 } // [Optional(1), nil, Optional(3), nil, Optional(5)]
```

### 2.2 filter

根据条件筛选数组元素：

```swift
// 基本过滤
let numbers = [1, 2, 3, 4, 5, 6]
let evens = numbers.filter { $0 % 2 == 0 } // [2, 4, 6]

// 复杂条件
let words = ["swift", "kotlin", "ruby", "python"]
let sWords = words.filter { $0.hasPrefix("s") } // ["swift"]

// 链式调用
let evenSquares = numbers
    .filter { $0 % 2 == 0 }
    .map { $0 * $0 }
```

### 2.3 reduce

将数组元素组合为单个值：

```swift
// 基本用法
let numbers = [1, 2, 3, 4, 5]
let sum = numbers.reduce(0, +) // 15

// 自定义组合逻辑
let product = numbers.reduce(1) { $0 * $1 } // 120

// 字符串拼接
let words = ["Hello", "Swift", "World"]
let sentence = words.reduce("") { $0 + " " + $1 }.trimmingCharacters(in: .whitespaces)
```

### 2.4 flatMap 和 compactMap

处理嵌套数组和可选值：

```swift
// flatMap：展平嵌套数组
let nestedArray = [[1, 2, 3], [4, 5, 6]]
let flattened = nestedArray.flatMap { $0 } // [1, 2, 3, 4, 5, 6]

// compactMap：过滤nil并解包可选值
let strings = ["1", "2", "three", "4", "5"]
let numbers = strings.compactMap { Int($0) } // [1, 2, 4, 5]
```

## 3. 函数式编程模式

### 3.1 函数组合

```swift
// 函数组合操作符
infix operator >>> : AdditionPrecedence
func >>> <A, B, C>(f: @escaping (A) -> B, g: @escaping (B) -> C) -> (A) -> C {
    return { g(f($0)) }
}

// 使用示例
let toString: (Int) -> String = { String($0) }
let addPrefix: (String) -> String = { "Number: " + $0 }
let process = toString >>> addPrefix

let result = process(42) // "Number: 42"
```

### 3.2 柯里化（Currying）

```swift
// 普通函数
func add(_ a: Int, _ b: Int) -> Int {
    return a + b
}

// 柯里化版本
func curriedAdd(_ a: Int) -> (Int) -> Int {
    return { b in a + b }
}

// 使用示例
let add5 = curriedAdd(5)
let result = add5(3) // 8
```

### 3.3 函数式数据转换

```swift
// 使用函数式方法处理数据
struct User {
    let name: String
    let age: Int
}

let users = [
    User(name: "Alice", age: 25),
    User(name: "Bob", age: 30),
    User(name: "Charlie", age: 35)
]

// 获取所有成年用户的名字
let adultNames = users
    .filter { $0.age >= 18 }
    .map { $0.name }
    .sorted()
```

## 4. 实际应用场景

### 4.1 数据转换

```swift
// JSON数据处理
struct APIResponse {
    let data: [[String: Any]]
}

func processAPIResponse(_ response: APIResponse) -> [User] {
    return response.data
        .compactMap { dict -> User? in
            guard let name = dict["name"] as? String,
                  let age = dict["age"] as? Int
            else { return nil }
            return User(name: name, age: age)
        }
}
```

### 4.2 事件处理

```swift
// 事件处理链
typealias EventHandler = (Event) -> Void

func addLogging(to handler: @escaping EventHandler) -> EventHandler {
    return { event in
        print("处理事件: \(event)")
        handler(event)
    }
}

func addValidation(to handler: @escaping EventHandler) -> EventHandler {
    return { event in
        guard event.isValid else { return }
        handler(event)
    }
}
```

### 4.3 状态管理

```swift
// 状态更新函数
struct State {
    let count: Int
}

enum Action {
    case increment
    case decrement
}

func reducer(_ state: State, _ action: Action) -> State {
    switch action {
    case .increment:
        return State(count: state.count + 1)
    case .decrement:
        return State(count: state.count - 1)
    }
}
```

## 5. 最佳实践

### 5.1 何时使用函数式编程

适合场景：

- 数据转换和处理
- 事件处理
- 状态管理
- 并发编程
- 可测试性要求高的代码

### 5.2 注意事项

- 保持函数纯净，避免副作用
- 适度使用，不要过度函数式
- 考虑代码可读性
- 注意性能影响
- 合理使用类型系统

### 5.3 性能优化

```swift
// 使用lazy避免不必要的计算
let numbers = Array(1...1000)
let lazyResult = numbers
    .lazy
    .filter { $0 % 2 == 0 }
    .map { $0 * 2 }
    .prefix(5)
```

## 6. 参考资料

- [Swift 官方文档](https://docs.swift.org)
- [Swift Evolution](https://github.com/apple/swift-evolution)
- [Functional Swift](https://www.objc.io/books/functional-swift/)
- [Point-Free](https://www.pointfree.co)

## 7. 总结

函数式编程在 Swift 中是一个强大的工具，它可以帮助我们：

- 编写更清晰、更可维护的代码
- 更好地处理数据转换
- 提高代码的可测试性
- 减少状态管理的复杂性

关键是要在实际项目中找到面向对象编程和函数式编程的平衡点，根据具体场景选择合适的编程范式。
